"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var t=require("shelljs"),e=require("child_process");function s(t){return t&&"object"==typeof t&&"default"in t?t:{default:t}}var o=s(t),r=s(e);const i=(t,e)=>r.default.spawn(t,{cwd:e,shell:!0,stdio:"inherit"}),c=(t,e)=>new Promise((s=>{o.default.exec(e,{cwd:t,silent:!0},((t,e,o)=>s({code:t,stdout:e,stderr:o})))})),n=async t=>c(t,"git remote -v");exports.existGitRepo=t=>new Promise((e=>{o.default.exec("git status",{cwd:t,silent:!0},(t=>e(0===t)))})),exports.gitAddAll=async t=>c("git add .",t),exports.gitBranchCurrent=async t=>{const{code:e,stdout:s,stderr:o}=await c(t,"git branch --show-current");if(0===e)return s.trim();process.exit(1)},exports.gitBranchLocal=async t=>c("git branch",t),exports.gitBranchR=async t=>c("git banch -r",t),exports.gitCheckoutB=async(t,e,s)=>c(t,`git checkout -b ${e} ${s}`),exports.gitCheckoutBSpawn=async(t,e,s)=>new Promise((o=>{i(`git checkout -b ${e}  ${s}`,t).on("close",(t=>{o(t)}))})),exports.gitCheckoutSpawn=async(t,e)=>new Promise((s=>{i(`git checkout ${e}`,t).on("close",(t=>{s(t)}))})),exports.gitCommitM=async(t,e)=>c("git commit -m "+e,t),exports.gitFetchRepo=async(t,e="ro_cli_upstream")=>c(t,"git fetch "+e),exports.gitLocalOriginURI=async t=>{const{code:e,stderr:s,stdout:o}=await n(t);0!==e&&(console.log(s),process.exit(1));return o.split(" ")[0].split("\t")[1]},exports.gitMergeTargetToLocal=async(t,e)=>new Promise((s=>{i(`git merge ${e}`,t).on("close",(t=>{s(t)}))})),exports.gitPushOrigin=async(t,e="")=>c(`git push origin ${e}`,t),exports.gitPushOriginU=async(t,e="")=>c(`git push -u origin ${e}`,t),exports.gitRemoteAdd=async(t,e)=>c(t,`git remote add ro_cli_upstream ${e}`),exports.gitRemoteRemove=async(t,e="ro_cli_upstream")=>c(t,"git remote remove "+e),exports.gitRemoteV=n;//# sourceMappingURL=git.mini.js.map
