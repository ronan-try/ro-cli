!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("shelljs"),require("child_process")):"function"==typeof define&&define.amd?define(["exports","shelljs","child_process"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).git={},e.shelljs,e.child_process)}(this,(function(e,t,i){"use strict";function s(e){return e&&"object"==typeof e&&"default"in e?e:{default:e}}var o=s(t);const c=(e,t)=>i.spawn(e,{cwd:t,shell:!0,stdio:"inherit"}),n=(e,t)=>new Promise((i=>{o.default.exec(t,{cwd:e,silent:!0},((e,t,s)=>i({code:e,stdout:t,stderr:s})))})),r=async e=>n(e,"git remote -v");e.existGitRepo=e=>new Promise((t=>{o.default.exec("git status",{cwd:e,silent:!0},(e=>t(0===e)))})),e.gitAddAll=async e=>n("git add .",e),e.gitBranchCurrent=async e=>{const{code:t,stdout:i,stderr:s}=await n(e,"git branch --show-current");if(0===t)return i.trim();process.exit(1)},e.gitBranchLocal=async e=>n("git branch",e),e.gitBranchR=async e=>n("git banch -r",e),e.gitCheckoutB=async(e,t,i)=>n(e,`git checkout -b ${t} ${i}`),e.gitCheckoutBSpawn=async(e,t,i)=>new Promise((s=>{c(`git checkout -b ${t}  ${i}`,e).on("close",(e=>{s(e)}))})),e.gitCheckoutSpawn=async(e,t)=>new Promise((i=>{c(`git checkout ${t}`,e).on("close",(e=>{i(e)}))})),e.gitCommitM=async(e,t)=>n("git commit -m "+t,e),e.gitFetchRepo=async(e,t="ro_cli_upstream")=>n(e,"git fetch "+t),e.gitLocalOriginURI=async e=>{const{code:t,stderr:i,stdout:s}=await r(e);0!==t&&(console.log(i),process.exit(1));return s.split(" ")[0].split("\t")[1]},e.gitMergeTargetToLocal=async(e,t)=>new Promise((i=>{c(`git merge ${t}`,e).on("close",(e=>{i(e)}))})),e.gitPushOrigin=async(e,t="")=>n(`git push origin ${t}`,e),e.gitPushOriginU=async(e,t="")=>n(`git push -u origin ${t}`,e),e.gitRemoteAdd=async(e,t)=>n(e,`git remote add ro_cli_upstream ${t}`),e.gitRemoteRemove=async(e,t="ro_cli_upstream")=>n(e,"git remote remove "+t),e.gitRemoteV=r,Object.defineProperty(e,"__esModule",{value:!0})}));//# sourceMappingURL=git.mini.js.map
